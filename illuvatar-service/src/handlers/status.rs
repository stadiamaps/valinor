use http::StatusCode;
use serde_json::json;
use tracing::error;
use valhalla_microservice::WorkerResult;
use valhalla_proto::Api;
use valhalla_proto::options::Format;
use valhalla_proto::status::{
    HasHasAdmins, HasHasLiveTraffic, HasHasTiles, HasHasTimezones, HasHasTransitTiles,
    HasOsmChangeset,
};
use valhalla_response::StatusResponse;

pub fn status(request: Api) -> WorkerResult {
    if let Some(options) = &request.options
        && Format::try_from(options.format) == Ok(Format::Pbf)
    {
        unimplemented!("TODO: PBF status")
    } else {
        json_status(request)
    }
}

fn json_status(request: Api) -> WorkerResult {
    let Some(status) = request.status else {
        error!("Unexpected internal request without status info.");

        return WorkerResult::json(
            StatusCode::INTERNAL_SERVER_ERROR,
            json!({
                "message": "Missing status message from the internal Protobuf API. Please open an issue on GitHub!"
            }),
        );
    };

    let res = StatusResponse {
        version: status.version,
        tileset_last_modified: status.tileset_last_modified,
        available_actions: status.available_actions,
        has_tiles: status.has_has_tiles.map(|HasHasTiles::HasTiles(v)| v),
        has_admins: status.has_has_admins.map(|HasHasAdmins::HasAdmins(v)| v),
        has_timezones: status
            .has_has_timezones
            .map(|HasHasTimezones::HasTimezones(v)| v),
        has_live_traffic: status
            .has_has_live_traffic
            .map(|HasHasLiveTraffic::HasLiveTraffic(v)| v),
        has_transit_tiles: status
            .has_has_transit_tiles
            .map(|HasHasTransitTiles::HasTransitTiles(v)| v),
        osm_changeset: status
            .has_osm_changeset
            .map(|HasOsmChangeset::OsmChangeset(v)| v),
    };

    WorkerResult::json(StatusCode::OK, res)
}

#[cfg(test)]
mod tests {
    use super::*;
    use valhalla_proto::prost::Message;

    #[test]
    fn status_happy_path() {
        // Happy path test for generating a status response
        // using a protobuf capture from a working server.
        const STATUS_MESSAGE: &[u8] = &[
            0xa, 0x43, 0x12, 0x5, 0x65, 0x6e, 0x2d, 0x55, 0x53, 0x40, 0xc, 0x50, 0x0, 0x58, 0x0,
            0x6a, 0xf, 0x8, 0x0, 0x12, 0xb, 0xa, 0x3, 0xb8, 0x3, 0x0, 0x1a, 0x4, 0x6e, 0x6f, 0x6e,
            0x65, 0xb8, 0x1, 0x0, 0xc5, 0x1, 0x0, 0x0, 0x80, 0x3f, 0xd0, 0x1, 0x0, 0xa8, 0x2, 0x0,
            0xb8, 0x2, 0x0, 0xc8, 0x2, 0x0, 0xe0, 0x2, 0x1, 0x80, 0x3, 0x0, 0x90, 0x3, 0x0, 0xb0,
            0x3, 0xff, 0xff, 0xff, 0xff, 0xf, 0x22, 0xa3, 0x1, 0x32, 0x5, 0x33, 0x2e, 0x35, 0x2e,
            0x31, 0x38, 0xee, 0xc5, 0xc4, 0xc5, 0x6, 0x42, 0x6, 0x73, 0x74, 0x61, 0x74, 0x75, 0x73,
            0x42, 0x8, 0x63, 0x65, 0x6e, 0x74, 0x72, 0x6f, 0x69, 0x64, 0x42, 0x9, 0x65, 0x78, 0x70,
            0x61, 0x6e, 0x73, 0x69, 0x6f, 0x6e, 0x42, 0x11, 0x74, 0x72, 0x61, 0x6e, 0x73, 0x69,
            0x74, 0x5f, 0x61, 0x76, 0x61, 0x69, 0x6c, 0x61, 0x62, 0x6c, 0x65, 0x42, 0x10, 0x74,
            0x72, 0x61, 0x63, 0x65, 0x5f, 0x61, 0x74, 0x74, 0x72, 0x69, 0x62, 0x75, 0x74, 0x65,
            0x73, 0x42, 0xb, 0x74, 0x72, 0x61, 0x63, 0x65, 0x5f, 0x72, 0x6f, 0x75, 0x74, 0x65,
            0x42, 0x9, 0x69, 0x73, 0x6f, 0x63, 0x68, 0x72, 0x6f, 0x6e, 0x65, 0x42, 0xf, 0x6f, 0x70,
            0x74, 0x69, 0x6d, 0x69, 0x7a, 0x65, 0x64, 0x5f, 0x72, 0x6f, 0x75, 0x74, 0x65, 0x42,
            0x12, 0x73, 0x6f, 0x75, 0x72, 0x63, 0x65, 0x73, 0x5f, 0x74, 0x6f, 0x5f, 0x74, 0x61,
            0x72, 0x67, 0x65, 0x74, 0x73, 0x42, 0x6, 0x68, 0x65, 0x69, 0x67, 0x68, 0x74, 0x42, 0x5,
            0x72, 0x6f, 0x75, 0x74, 0x65, 0x42, 0x6, 0x6c, 0x6f, 0x63, 0x61, 0x74, 0x65,
        ];

        let request = Api::decode(STATUS_MESSAGE).unwrap();
        let WorkerResult::HttpResponse {
            status_code,
            headers,
            body,
        } = status(request)
        else {
            panic!("Expected an HTTP response.");
        };

        assert_eq!(status_code, StatusCode::OK);
        assert_eq!(
            headers.get("Content-Type").unwrap(),
            "application/json;charset=utf-8"
        );

        let status_res: StatusResponse = serde_json::from_slice(&body).unwrap();

        if !cfg!(miri) {
            insta::assert_yaml_snapshot!(status_res);
        }
    }
}
